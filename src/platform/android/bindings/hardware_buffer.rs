/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ARect {
    pub left: i32,
    pub top: i32,
    pub right: i32,
    pub bottom: i32,
}
#[test]
fn bindgen_test_layout_ARect() {
    assert_eq!(
        ::std::mem::size_of::<ARect>(),
        16usize,
        concat!("Size of: ", stringify!(ARect))
    );
    assert_eq!(
        ::std::mem::align_of::<ARect>(),
        4usize,
        concat!("Alignment of ", stringify!(ARect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ARect>())).left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ARect),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ARect>())).top as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ARect),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ARect>())).right as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ARect),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ARect>())).bottom as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ARect),
            "::",
            stringify!(bottom)
        )
    );
}
/// Corresponding formats:
/// Vulkan: VK_FORMAT_R8G8B8A8_UNORM
/// OpenGL ES: GL_RGBA8
pub const AHARDWAREBUFFER_FORMAT_R8G8B8A8_UNORM: _bindgen_ty_1 = 1;
/// Corresponding formats:
/// Vulkan: VK_FORMAT_R8G8B8A8_UNORM
/// OpenGL ES: GL_RGBA8
pub const AHARDWAREBUFFER_FORMAT_R8G8B8X8_UNORM: _bindgen_ty_1 = 2;
/// Corresponding formats:
/// Vulkan: VK_FORMAT_R8G8B8_UNORM
/// OpenGL ES: GL_RGB8
pub const AHARDWAREBUFFER_FORMAT_R8G8B8_UNORM: _bindgen_ty_1 = 3;
/// Corresponding formats:
/// Vulkan: VK_FORMAT_R5G6B5_UNORM_PACK16
/// OpenGL ES: GL_RGB565
pub const AHARDWAREBUFFER_FORMAT_R5G6B5_UNORM: _bindgen_ty_1 = 4;
/// Corresponding formats:
/// Vulkan: VK_FORMAT_R16G16B16A16_SFLOAT
/// OpenGL ES: GL_RGBA16F
pub const AHARDWAREBUFFER_FORMAT_R16G16B16A16_FLOAT: _bindgen_ty_1 = 22;
/// Corresponding formats:
/// Vulkan: VK_FORMAT_A2B10G10R10_UNORM_PACK32
/// OpenGL ES: GL_RGB10_A2
pub const AHARDWAREBUFFER_FORMAT_R10G10B10A2_UNORM: _bindgen_ty_1 = 43;
/// An opaque binary blob format that must have height 1, with width equal to
/// the buffer size in bytes.
pub const AHARDWAREBUFFER_FORMAT_BLOB: _bindgen_ty_1 = 33;
/// Buffer pixel formats.
pub type _bindgen_ty_1 = u32;
pub const AHARDWAREBUFFER_USAGE_CPU_READ_NEVER: _bindgen_ty_2 = 0;
pub const AHARDWAREBUFFER_USAGE_CPU_READ_RARELY: _bindgen_ty_2 = 2;
pub const AHARDWAREBUFFER_USAGE_CPU_READ_OFTEN: _bindgen_ty_2 = 3;
pub const AHARDWAREBUFFER_USAGE_CPU_READ_MASK: _bindgen_ty_2 = 15;
pub const AHARDWAREBUFFER_USAGE_CPU_WRITE_NEVER: _bindgen_ty_2 = 0;
pub const AHARDWAREBUFFER_USAGE_CPU_WRITE_RARELY: _bindgen_ty_2 = 32;
pub const AHARDWAREBUFFER_USAGE_CPU_WRITE_OFTEN: _bindgen_ty_2 = 48;
pub const AHARDWAREBUFFER_USAGE_CPU_WRITE_MASK: _bindgen_ty_2 = 240;
pub const AHARDWAREBUFFER_USAGE_GPU_SAMPLED_IMAGE: _bindgen_ty_2 = 256;
pub const AHARDWAREBUFFER_USAGE_GPU_COLOR_OUTPUT: _bindgen_ty_2 = 512;
pub const AHARDWAREBUFFER_USAGE_PROTECTED_CONTENT: _bindgen_ty_2 = 16384;
pub const AHARDWAREBUFFER_USAGE_VIDEO_ENCODE: _bindgen_ty_2 = 65536;
/// The buffer will be used for sensor direct data
pub const AHARDWAREBUFFER_USAGE_SENSOR_DIRECT_DATA: _bindgen_ty_2 = 8388608;
/// The buffer will be used for sensor direct data
pub const AHARDWAREBUFFER_USAGE_GPU_DATA_BUFFER: _bindgen_ty_2 = 16777216;
/// The buffer will be used for sensor direct data
pub const AHARDWAREBUFFER_USAGE_VENDOR_0: _bindgen_ty_2 = 268435456;
/// The buffer will be used for sensor direct data
pub const AHARDWAREBUFFER_USAGE_VENDOR_1: _bindgen_ty_2 = 536870912;
/// The buffer will be used for sensor direct data
pub const AHARDWAREBUFFER_USAGE_VENDOR_2: _bindgen_ty_2 = 1073741824;
/// The buffer will be used for sensor direct data
pub const AHARDWAREBUFFER_USAGE_VENDOR_3: _bindgen_ty_2 = 2147483648;
/// The buffer will be used for sensor direct data
pub const AHARDWAREBUFFER_USAGE_VENDOR_4: _bindgen_ty_2 = 281474976710656;
/// The buffer will be used for sensor direct data
pub const AHARDWAREBUFFER_USAGE_VENDOR_5: _bindgen_ty_2 = 562949953421312;
/// The buffer will be used for sensor direct data
pub const AHARDWAREBUFFER_USAGE_VENDOR_6: _bindgen_ty_2 = 1125899906842624;
/// The buffer will be used for sensor direct data
pub const AHARDWAREBUFFER_USAGE_VENDOR_7: _bindgen_ty_2 = 2251799813685248;
/// The buffer will be used for sensor direct data
pub const AHARDWAREBUFFER_USAGE_VENDOR_8: _bindgen_ty_2 = 4503599627370496;
/// The buffer will be used for sensor direct data
pub const AHARDWAREBUFFER_USAGE_VENDOR_9: _bindgen_ty_2 = 9007199254740992;
/// The buffer will be used for sensor direct data
pub const AHARDWAREBUFFER_USAGE_VENDOR_10: _bindgen_ty_2 = 18014398509481984;
/// The buffer will be used for sensor direct data
pub const AHARDWAREBUFFER_USAGE_VENDOR_11: _bindgen_ty_2 = 36028797018963968;
/// The buffer will be used for sensor direct data
pub const AHARDWAREBUFFER_USAGE_VENDOR_12: _bindgen_ty_2 = 72057594037927936;
/// The buffer will be used for sensor direct data
pub const AHARDWAREBUFFER_USAGE_VENDOR_13: _bindgen_ty_2 = 144115188075855872;
/// The buffer will be used for sensor direct data
pub const AHARDWAREBUFFER_USAGE_VENDOR_14: _bindgen_ty_2 = 288230376151711744;
/// The buffer will be used for sensor direct data
pub const AHARDWAREBUFFER_USAGE_VENDOR_15: _bindgen_ty_2 = 576460752303423488;
/// The buffer will be used for sensor direct data
pub const AHARDWAREBUFFER_USAGE_VENDOR_16: _bindgen_ty_2 = 1152921504606846976;
/// The buffer will be used for sensor direct data
pub const AHARDWAREBUFFER_USAGE_VENDOR_17: _bindgen_ty_2 = 2305843009213693952;
/// The buffer will be used for sensor direct data
pub const AHARDWAREBUFFER_USAGE_VENDOR_18: _bindgen_ty_2 = 4611686018427387904;
/// The buffer will be used for sensor direct data
pub const AHARDWAREBUFFER_USAGE_VENDOR_19: _bindgen_ty_2 = 9223372036854775808;
pub type _bindgen_ty_2 = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AHardwareBuffer_Desc {
    pub width: u32,
    pub height: u32,
    pub layers: u32,
    pub format: u32,
    pub usage: u64,
    pub stride: u32,
    pub rfu0: u32,
    pub rfu1: u64,
}
#[test]
fn bindgen_test_layout_AHardwareBuffer_Desc() {
    assert_eq!(
        ::std::mem::size_of::<AHardwareBuffer_Desc>(),
        40usize,
        concat!("Size of: ", stringify!(AHardwareBuffer_Desc))
    );
    assert_eq!(
        ::std::mem::align_of::<AHardwareBuffer_Desc>(),
        8usize,
        concat!("Alignment of ", stringify!(AHardwareBuffer_Desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AHardwareBuffer_Desc>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AHardwareBuffer_Desc>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AHardwareBuffer_Desc>())).layers as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(layers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AHardwareBuffer_Desc>())).format as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AHardwareBuffer_Desc>())).usage as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AHardwareBuffer_Desc>())).stride as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AHardwareBuffer_Desc>())).rfu0 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(rfu0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AHardwareBuffer_Desc>())).rfu1 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(rfu1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AHardwareBuffer {
    _unused: [u8; 0],
}
extern "C" {
    /// Allocates a buffer that backs an AHardwareBuffer using the passed
    /// AHardwareBuffer_Desc.
    ///
    /// Returns NO_ERROR on success, or an error number of the allocation fails for
    /// any reason.
    #[link_name = "\u{1}_AHardwareBuffer_allocate"]
    pub fn AHardwareBuffer_allocate(
        desc: *const AHardwareBuffer_Desc,
        outBuffer: *mut *mut AHardwareBuffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Acquire a reference on the given AHardwareBuffer object.  This prevents the
    /// object from being deleted until the last reference is removed.
    #[link_name = "\u{1}_AHardwareBuffer_acquire"]
    pub fn AHardwareBuffer_acquire(buffer: *mut AHardwareBuffer);
}
extern "C" {
    /// Remove a reference that was previously acquired with
    /// AHardwareBuffer_acquire().
    #[link_name = "\u{1}_AHardwareBuffer_release"]
    pub fn AHardwareBuffer_release(buffer: *mut AHardwareBuffer);
}
extern "C" {
    /// Return a description of the AHardwareBuffer in the passed
    /// AHardwareBuffer_Desc struct.
    #[link_name = "\u{1}_AHardwareBuffer_describe"]
    pub fn AHardwareBuffer_describe(
        buffer: *const AHardwareBuffer,
        outDesc: *mut AHardwareBuffer_Desc,
    );
}
extern "C" {
    #[link_name = "\u{1}_AHardwareBuffer_lock"]
    pub fn AHardwareBuffer_lock(
        buffer: *mut AHardwareBuffer,
        usage: u64,
        fence: i32,
        rect: *const ARect,
        outVirtualAddress: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_AHardwareBuffer_unlock"]
    pub fn AHardwareBuffer_unlock(
        buffer: *mut AHardwareBuffer,
        fence: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_AHardwareBuffer_sendHandleToUnixSocket"]
    pub fn AHardwareBuffer_sendHandleToUnixSocket(
        buffer: *const AHardwareBuffer,
        socketFd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_AHardwareBuffer_recvHandleFromUnixSocket"]
    pub fn AHardwareBuffer_recvHandleFromUnixSocket(
        socketFd: ::std::os::raw::c_int,
        outBuffer: *mut *mut AHardwareBuffer,
    ) -> ::std::os::raw::c_int;
}
